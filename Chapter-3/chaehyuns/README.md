<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> fb20b8f6479e02075d393e253cb1f721dab49775
# 3장

# 📌 5개 이하의 `public` 메서드만 노출하세요

20개의 메서드를 포함하는 클래스 vs 하나의 `public` 메서드와 20개의 `private` 메서드를 가진 클래스

→ 후자가 더 작은 클래스이다. 따라서 클래스의 크기에 관한 기준으로 public 메서드(protected 메서드 포함)의 개수를 사용할 것을 권장합니다.

책에서 제안하는 적절한 `public` 메서드의 개수: 5개

## ✅ 작은 클래스의 장점

- 우아함, 유지보수성, 응집도, 테스트 가능성 향상
- 실수할 가능성이 줄어든다.
- 다른 객체와 조화를 이루기 쉽다.
- 에러를 찾고 수정하기 쉽다.
- 메서드와 프로퍼티를 더 가까운 위치에 모아둘 수 있기 때문에 응집도 향상
  - 두 개의 프로퍼티를 포함하는 클래스가 있을 때, 하나의 프로퍼티는 두 개의 메서드에서만 사용하고 다른 하나의 프로퍼티는 다른 3개의 메서드에서만 사용한다면, 이 클래스는 거의 연관성이 없는 독립적인 두 부분이 한 데 뭉쳐있는 상태라고 볼 수 있습니다.
- 모든 시나리오 쉽게 재형 → 테스트 용이

# 📌 정적 메서드를 사용하지 마세요

문맥과 무관하게 정적 메서드의 사용 여부는 OOP를 전혀 이해하지 못하고 있는 형편없는 프로그래머를 식별할 수 있는 완벽한 지표입니다.

## ✅ 객체 대 컴퓨터 사고

컴퓨터는 우리가 명령어를 제공하기를 기대하고, 제공된 명령어를 차례대로 실행합니다. 이것이 프로그래머들이 수년간 소프트웨어를 작성해 왔던 방식입니다. 이 방식의 장점은 프로그래머가 CPU와 가까운 위치에서 다음에 수행될 작업을 CPU에게 직접 지시할 수 있다는 것입니다.

하지만 우리는 CPU에게 할 일을 지시하는 것이 아니라 정의해야 합니다. 순차적인 사고 방식은 규모가 큰 프로젝트에서 힘들어집니다.

컴퓨터처럼 생각하기에서는 명령의 실행 흐름을 제어할 책임이 우리에게 있습니다.

객체지향적으로 생각하기에서는 누가 누구인지만 우리가 정의하고, 객체들이 필요에 따라 스스로 상호작용합니다.

```kotlin
class Max implements Number {
	private final Number a;
	private final Number b;

	public Max(Number left, Number right) {
		this.a = left;
		this.b = right;
	}
}

Number x = new Max(5, 9)
```

위의 코드는 x가 그저 5와 9 사이의 최댓값 이라는 사실을 정의했을 뿐입니다.

구현에는 관심이 없으며, CPU에 어떤 지시도 내리지 않습니다. 그저 인스턴스화하고 있을 뿐입니다.

반대로 정적 메서드는 OOP와 전혀 상관이 없으며, 객체지향 언어의 문법을 이용해 절차적인 코드를 작성하도록 부추길 뿐입니다.

## ✅ 선언적인 스타일 대 명령형 스타일

### 📍 명령형 프로그래밍

- 프로그램의 상태를 변경하는 문장을 사용해서 계산 방식을 서술
- 컴퓨터처럼 연산을 차례대로 실행
- 메서드를 호출하자마자 값 반환
- 작업을 완료하는데 필요한 모든 정적 메서드를 순차적으로 호출해야 한다.

### 📍 선언적 프로그래밍

- 제어 흐름을 서술하지 않고 계산 로직을 표현
- 자연스러운 사고 패러다임
- `엔티티`와 이들 사이의 `관계`로 구성

1. 객체를 선언만 하고, CPU에게 어떠한 일을 하라고 지시하지 않아도 된다.

   - → 우리가 직접 성능 최적화를 엄격하게 제어하는게 가능하기 때문에 실제로는 더 빠를 수 있다.
   - 필요한 메서드만 호출 가능
   - CPU에게 결과가 실제로 필요한 시점과 위치를 결정하도록 위임하며, CPU는 요청이 있을 경우에만 계산을 실행한다.
   - 최적화와 관련해서 코드에 관해 통제할 수 있는 부분이 늘어날수록 유지보수하기가 더 쉬워진다.

1. 다형성

   - 다형성이란, 코드 블록 사이의 의존성을 끊을 수 있는 능력을 가리킨다. → 유지보수 용이
   - 객체를 다른 모든 객체로부터 완전히 분리하기 위해서는 어떤 메서드나 주 생성자 안에서도 new 연산자를 사용해서는 안된다.
   - 객체는 일급 시민 이지만 정적메서드는 아니다.
   - 객체를 다른 모든 객체로부터 완전히 분리하기 위해서는 어떤 메서드나 주 생성자 안에서도 new 연산자를 사용해서는 안된다.

1. 표현력

   - 선언적인 방식은 결과를 이야기하는데 반해, 명령적인 방식은 수행 가능한 한 가지 방법을 이야기 합니다.
   - 알고리즘과 실행 방식 대신, 객체와 행동의 관점에서 생각하기 시작하면 된다.

1. 코드 응집도
   - 관련된 책임을 한 곳에 모아둠 → 실수로라도 분리할 수 없음
   - 시간적 결합 문제를 해결할 수 있다.
   - 기술적으로 명령적인 스타일을 선언적인 스타일과 함께 조합하는 것은 불가능하다. 일단 명령적인 스타일을 사용하기 시작하면, 계속해서 명령적인 스타일에 머무를 수 밖에 없고, 결과적으로 코드 전체가 명령적인 스타일을 따르게 된다.
   - 정적 메서드 제거 방법: 정적 메서드가 아닌 객체와 협력할 수 있도록 직접 만든 새로운 클래스를 추가하고, 이 클래스를 이용해서 정적 메서드를 감싸서 종양을 고립시키는 것이다.

## ✅ 유틸리티 클래스

- 유틸리티 클래스는 인스턴스를 생성하지 않기 때문에 클래스가 아니다.
- 유틸리티 클래스는 어떤 것의 팩토리도 아니기 때문에 진짜 클래스라고 부를 수 없습니다.
- 유틸리티 클래스 안에는 객체가 존재하지 않는다. 따라서 어떤 것도 변경할 수 없다.
- OOP에서는 전역 변수를 사용하지 않는다. 왜냐하면 전역 변수는 OOP와 아무런 상관이 없기 때문이다. 전역 변수는 순수하게 절차적인 언어를 위해 존재하는 장치이다.

## ✅ 싱글톤 패턴

- 싱클톤 클래스와 유틸리티 클래스는 거의 동일한 일을 수행
- 다른점: 싱글톤을 끊을 수 있는 의존성으로 연결되어 있는데 반해, 유틸리티 클래스는 끊기 불가능한 하드 코딩된 결합도를 가진다.

## ✅ 조합 가능한 데코레이터

- 순수한 OOP에서는 C 와 같은 절차적인 언어로부터 물려받은 연산자가 필요하지 않다.
- if, for, switch, while이 필요하지 않다. 클래스 If, For, Switch, While이 필요하다.

객체 지향 프로그래밍이란, 더 작은 객체들을 기반으로 더 큰 객체들을 조합하는 작업이다.

반대로, 정적 메서드는 조합이 불가능합니다. 정적 메서드는 바로 전에 설명한 모든 일들을 불가능하게 만든다.

# 📌 인자의 값으로 NULL을 절대 허용하지 마세요

```kotlin
 public Iterable<File> find(String mask) {
	 if(mask == null) {
			// 모든 파일을 찾는다.
	 } else {
		 // 마스크를 사용해서 파일을 찾는다.
	 }
 }
```

이 코드는 mask 객체에게 말하는 대신, 이 객체를 피하고 무시합니다. mask 객체를 존중한다면, 객체가 우리를 위해 뭔가를 가지고 있는지, 아니면 무일푼인지 스스로 결정하게 합니다. 객체의 얼굴만으로 그를 판단해서는 안됩니다.

null을 처리하는 방법

1. 방어적인 방법
   - NULL을 체크한 후 예외를 던진다.
2. 무시하는 방법
   - NULL에 대해 아무런 대비도 하지 않는다.
   - NullPointerException이 던져질 것이고 호출한 쪽에서 실수한 것을 알린다.

NULL 확인 로직으로 코드를 오염시키지 말아야 한다.

# 📌 충성스러우면서 불변이거나, 아니면 상수이거나

불변 객체는 실제 객체가 어디에 있는지, 그리고 그 객체를 어떻게 사용해야 하는 지 알고 있다. 이것이 핵심이다. 불변 객체는 좌표를 알고, 우리는 그 좌표를 상태라고 부른다.

불변 객체는 좌표를 알고 있고, 우리는 그 좌표를 상태라고 부른다.

웹 페이지나 파일에 관해 이야기 할 때, 이 점이 매우 또렷한데, 실세계가 정말로 실제하기 때문이다.

실세계 엔티티는 소프트웨어 외부 어딘가에 존재한다. 따라서 엔티티와 대표자를 쉽게 분리할 수 있다.

다른 말로 표현하면, 불변 객체는 자신이 대표한 실세계의 엔티티에 대해 충성스럽다. 결코 엔티티의 좌표를 변경하지 않는다. 어떤 경우에도 항상 동일한 엔티티를 대상으로 한다.

전통적인 불변 객체는 상태 변경이 필요할 때마다 새로운 객체를 생성한다. 하지만 ConstantList처럼 객체의 상태가 객체가 대표하는 실제 엔티티와 동일한 특별한 경우에는, `불변` 대신 `상수`라는 용어를 사용할 것을 제안한다.

객체는 배열이라는 실세계 엔티티를 대표하고, 객체의 상태는 바로 그 배열이다.

# 📌 절대 getter와 setter를 사용하지 마세요.

```kotlin
class Cash {
	private int dollars;

	public int getDollars() {
		return this.dollars;
	}

	public void setDollars(int value) {
		this.dollar = value;
	}
}
```

위의 코드는 가변 클래스이다. 메서드 이름도 잘못되었고, 어떤 생성자도 선언되어 있지 않고 있다.

Cash 클래스는 단순한 자료구조에 불과하다.

클래스와 구조체는 다르다. 클래스는 어떤 식으로든 멤버에 접근하는 것을 허용하지 않는다. 게다가 자신의 멤버를 보여주지도 않는다. 심지어 우리는 그 안에 dollars라는 멤버가 있는지 조차 알 수 없다.

모든 프로그래밍 스타일의 핵심 목표는 가시성의 범위를 축소해서 사물을 단순화시키는 것이다. 특정한 시점에 이해해야 하는 범위가 작을 수록, 소프트웨어의 유지보수성이 향상되고 이해하고 수정하기도 쉬워집니다.

사물들을 절차적인 세상의 것보다 더 단순하게 만들기 위해 OOP가 발명되었다는 사실에 모두가 동의했다. 객체는 모든 것을 송두리째 바꿔버렸습니다. 코드는 수동적인 존재가 되었고, 데이터는 능동적인 존재가 되었다.

코드는 더 이상 제왕이 아니다. 코드는 OOP에서 부차적인 요소이다. 객체는 일급 시민이며, 생성자를 통한 객체의 초기화가 곧 소프트웨어이다.

따라서 자료구조 대신 객체를 선택해야 하는 이유는 발가벗은 데이터가 절차적인 프로그래밍 스타일을 사용하도록 부추기기 때문이다.

Cash 클래스의 getter/setter는 Cash가 객체가 아닌, 존중 받을 가치도 없는 자료구조임라는 메시지를 전달한다.

getDollars() 보다는 dollars()가 Cash를 데이터로서 존중하는 방식이다.

# 📌 질문

114P. FP를 향한 움직임의 일환으로 도입된 Java의 람다 표현식은 진정한 객체지향 스타일로부터 우리를 멀어지게 하기 때문에 Java의 견고함을 약화시킨다고 생각합니다.

132P. 상수 객체가 설계하고, 유지보수하고, 이해하기 더 쉽기 때문에 불변 객체보다는 상수 객체를 사용하는 것이 좋습니다.

# 📌 5개 이하의 `public` 메서드만 노출하세요

20개의 메서드를 포함하는 클래스 vs 하나의 `public` 메서드와 20개의 `private` 메서드를 가진 클래스

→ 후자가 더 작은 클래스이다. 따라서 클래스의 크기에 관한 기준으로 public 메서드(protected 메서드 포함)의 개수를 사용할 것을 권장합니다.

책에서 제안하는 적절한 `public` 메서드의 개수: 5개

## ✅ 작은 클래스의 장점

- 우아함, 유지보수성, 응집도, 테스트 가능성 향상
- 실수할 가능성이 줄어든다.
- 다른 객체와 조화를 이루기 쉽다.
- 에러를 찾고 수정하기 쉽다.
- 메서드와 프로퍼티를 더 가까운 위치에 모아둘 수 있기 때문에 응집도 향상
  - 두 개의 프로퍼티를 포함하는 클래스가 있을 때, 하나의 프로퍼티는 두 개의 메서드에서만 사용하고 다른 하나의 프로퍼티는 다른 3개의 메서드에서만 사용한다면, 이 클래스는 거의 연관성이 없는 독립적인 두 부분이 한 데 뭉쳐있는 상태라고 볼 수 있습니다.
- 모든 시나리오 쉽게 재형 → 테스트 용이

# 📌 정적 메서드를 사용하지 마세요

문맥과 무관하게 정적 메서드의 사용 여부는 OOP를 전혀 이해하지 못하고 있는 형편없는 프로그래머를 식별할 수 있는 완벽한 지표입니다.

## ✅ 객체 대 컴퓨터 사고

컴퓨터는 우리가 명령어를 제공하기를 기대하고, 제공된 명령어를 차례대로 실행합니다. 이것이 프로그래머들이 수년간 소프트웨어를 작성해 왔던 방식입니다. 이 방식의 장점은 프로그래머가 CPU와 가까운 위치에서 다음에 수행될 작업을 CPU에게 직접 지시할 수 있다는 것입니다.

하지만 우리는 CPU에게 할 일을 지시하는 것이 아니라 정의해야 합니다. 순차적인 사고 방식은 규모가 큰 프로젝트에서 힘들어집니다.

컴퓨터처럼 생각하기에서는 명령의 실행 흐름을 제어할 책임이 우리에게 있습니다.

객체지향적으로 생각하기에서는 누가 누구인지만 우리가 정의하고, 객체들이 필요에 따라 스스로 상호작용합니다.

```kotlin
class Max implements Number {
	private final Number a;
	private final Number b;

	public Max(Number left, Number right) {
		this.a = left;
		this.b = right;
	}
}

Number x = new Max(5, 9)

```

위의 코드는 x가 그저 5와 9 사이의 최댓값 이라는 사실을 정의했을 뿐입니다.

구현에는 관심이 없으며, CPU에 어떤 지시도 내리지 않습니다. 그저 인스턴스화하고 있을 뿐입니다.

반대로 정적 메서드는 OOP와 전혀 상관이 없으며, 객체지향 언어의 문법을 이용해 절차적인 코드를 작성하도록 부추길 뿐입니다.

## ✅ 선언적인 스타일 대 명령형 스타일

### 📍 명령형 프로그래밍

- 프로그램의 상태를 변경하는 문장을 사용해서 계산 방식을 서술
- 컴퓨터처럼 연산을 차례대로 실행
- 메서드를 호출하자마자 값 반환
- 작업을 완료하는데 필요한 모든 정적 메서드를 순차적으로 호출해야 한다.

### 📍 선언적 프로그래밍

- 제어 흐름을 서술하지 않고 계산 로직을 표현
- 자연스러운 사고 패러다임
- `엔티티`와 이들 사이의 `관계`로 구성

1. 객체를 선언만 하고, CPU에게 어떠한 일을 하라고 지시하지 않아도 된다.
   - → 우리가 직접 성능 최적화를 엄격하게 제어하는게 가능하기 때문에 실제로는 더 빠를 수 있다.
   - 필요한 메서드만 호출 가능
   - CPU에게 결과가 실제로 필요한 시점과 위치를 결정하도록 위임하며, CPU는 요청이 있을 경우에만 계산을 실행한다.
   - 최적화와 관련해서 코드에 관해 통제할 수 있는 부분이 늘어날수록 유지보수하기가 더 쉬워진다.
2. 다형성
   - 다형성이란, 코드 블록 사이의 의존성을 끊을 수 있는 능력을 가리킨다. → 유지보수 용이
   - 객체를 다른 모든 객체로부터 완전히 분리하기 위해서는 어떤 메서드나 주 생성자 안에서도 new 연산자를 사용해서는 안된다.
   - 객체는 일급 시민 이지만 정적메서드는 아니다.
   - 객체를 다른 모든 객체로부터 완전히 분리하기 위해서는 어떤 메서드나 주 생성자 안에서도 new 연산자를 사용해서는 안된다.
3. 표현력
   - 선언적인 방식은 결과를 이야기하는데 반해, 명령적인 방식은 수행 가능한 한 가지 방법을 이야기 합니다.
   - 알고리즘과 실행 방식 대신, 객체와 행동의 관점에서 생각하기 시작하면 된다.
4. 코드 응집도
   - 관련된 책임을 한 곳에 모아둠 → 실수로라도 분리할 수 없음
   - 시간적 결합 문제를 해결할 수 있다.
   - 기술적으로 명령적인 스타일을 선언적인 스타일과 함께 조합하는 것은 불가능하다. 일단 명령적인 스타일을 사용하기 시작하면, 계속해서 명령적인 스타일에 머무를 수 밖에 없고, 결과적으로 코드 전체가 명령적인 스타일을 따르게 된다.
   - 정적 메서드 제거 방법: 정적 메서드가 아닌 객체와 협력할 수 있도록 직접 만든 새로운 클래스를 추가하고, 이 클래스를 이용해서 정적 메서드를 감싸서 종양을 고립시키는 것이다.

## ✅ 유틸리티 클래스

- 유틸리티 클래스는 인스턴스를 생성하지 않기 때문에 클래스가 아니다.
- 유틸리티 클래스는 어떤 것의 팩토리도 아니기 때문에 진짜 클래스라고 부를 수 없습니다.
- 유틸리티 클래스 안에는 객체가 존재하지 않는다. 따라서 어떤 것도 변경할 수 없다.
- OOP에서는 전역 변수를 사용하지 않는다. 왜냐하면 전역 변수는 OOP와 아무런 상관이 없기 때문이다. 전역 변수는 순수하게 절차적인 언어를 위해 존재하는 장치이다.

## ✅ 싱글톤 패턴

- 싱클톤 클래스와 유틸리티 클래스는 거의 동일한 일을 수행
- 다른점: 싱글톤을 끊을 수 있는 의존성으로 연결되어 있는데 반해, 유틸리티 클래스는 끊기 불가능한 하드 코딩된 결합도를 가진다.

## ✅ 조합 가능한 데코레이터

- 순수한 OOP에서는 C 와 같은 절차적인 언어로부터 물려받은 연산자가 필요하지 않다.
- if, for, switch, while이 필요하지 않다. 클래스 If, For, Switch, While이 필요하다.

객체 지향 프로그래밍이란, 더 작은 객체들을 기반으로 더 큰 객체들을 조합하는 작업이다.

반대로, 정적 메서드는 조합이 불가능합니다. 정적 메서드는 바로 전에 설명한 모든 일들을 불가능하게 만든다.

# 📌 인자의 값으로 NULL을 절대 허용하지 마세요

```kotlin
 public Iterable<File> find(String mask) {
	 if(mask == null) {
			// 모든 파일을 찾는다.
	 } else {
		 // 마스크를 사용해서 파일을 찾는다.
	 }
 }

```

이 코드는 mask 객체에게 말하는 대신, 이 객체를 피하고 무시합니다. mask 객체를 존중한다면, 객체가 우리를 위해 뭔가를 가지고 있는지, 아니면 무일푼인지 스스로 결정하게 합니다. 객체의 얼굴만으로 그를 판단해서는 안됩니다.

null을 처리하는 방법

1. 방어적인 방법
   - NULL을 체크한 후 예외를 던진다.
2. 무시하는 방법
   - NULL에 대해 아무런 대비도 하지 않는다.
   - NullPointerException이 던져질 것이고 호출한 쪽에서 실수한 것을 알린다.

NULL 확인 로직으로 코드를 오염시키지 말아야 한다.

# 📌 충성스러우면서 불변이거나, 아니면 상수이거나

불변 객체는 실제 객체가 어디에 있는지, 그리고 그 객체를 어떻게 사용해야 하는 지 알고 있다. 이것이 핵심이다. 불변 객체는 좌표를 알고, 우리는 그 좌표를 상태라고 부른다.

불변 객체는 좌표를 알고 있고, 우리는 그 좌표를 상태라고 부른다.

웹 페이지나 파일에 관해 이야기 할 때, 이 점이 매우 또렷한데, 실세계가 정말로 실제하기 때문이다.

실세계 엔티티는 소프트웨어 외부 어딘가에 존재한다. 따라서 엔티티와 대표자를 쉽게 분리할 수 있다.

다른 말로 표현하면, 불변 객체는 자신이 대표한 실세계의 엔티티에 대해 충성스럽다. 결코 엔티티의 좌표를 변경하지 않는다. 어떤 경우에도 항상 동일한 엔티티를 대상으로 한다.

전통적인 불변 객체는 상태 변경이 필요할 때마다 새로운 객체를 생성한다. 하지만 ConstantList처럼 객체의 상태가 객체가 대표하는 실제 엔티티와 동일한 특별한 경우에는, `불변` 대신 `상수`라는 용어를 사용할 것을 제안한다.

객체는 배열이라는 실세계 엔티티를 대표하고, 객체의 상태는 바로 그 배열이다.

# 📌 절대 getter와 setter를 사용하지 마세요.

```kotlin
class Cash {
	private int dollars;

	public int getDollars() {
		return this.dollars;
	}

	public void setDollars(int value) {
		this.dollar = value;
	}
}

```

위의 코드는 가변 클래스이다. 메서드 이름도 잘못되었고, 어떤 생성자도 선언되어 있지 않고 있다.

Cash 클래스는 단순한 자료구조에 불과하다.

클래스와 구조체는 다르다. 클래스는 어떤 식으로든 멤버에 접근하는 것을 허용하지 않는다. 게다가 자신의 멤버를 보여주지도 않는다. 심지어 우리는 그 안에 dollars라는 멤버가 있는지 조차 알 수 없다.

모든 프로그래밍 스타일의 핵심 목표는 가시성의 범위를 축소해서 사물을 단순화시키는 것이다. 특정한 시점에 이해해야 하는 범위가 작을 수록, 소프트웨어의 유지보수성이 향상되고 이해하고 수정하기도 쉬워집니다.

사물들을 절차적인 세상의 것보다 더 단순하게 만들기 위해 OOP가 발명되었다는 사실에 모두가 동의했다. 객체는 모든 것을 송두리째 바꿔버렸습니다. 코드는 수동적인 존재가 되었고, 데이터는 능동적인 존재가 되었다.

코드는 더 이상 제왕이 아니다. 코드는 OOP에서 부차적인 요소이다. 객체는 일급 시민이며, 생성자를 통한 객체의 초기화가 곧 소프트웨어이다.

따라서 자료구조 대신 객체를 선택해야 하는 이유는 발가벗은 데이터가 절차적인 프로그래밍 스타일을 사용하도록 부추기기 때문이다.

Cash 클래스의 getter/setter는 Cash가 객체가 아닌, 존중 받을 가치도 없는 자료구조임라는 메시지를 전달한다.

getDollars() 보다는 dollars()가 Cash를 데이터로서 존중하는 방식이다.

# 📌 질문

114P. FP를 향한 움직임의 일환으로 도입된 Java의 람다 표현식은 진정한 객체지향 스타일로부터 우리를 멀어지게 하기 때문에 Java의 견고함을 약화시킨다고 생각합니다.

132P. 상수 객체가 설계하고, 유지보수하고, 이해하기 더 쉽기 때문에 불변 객체보다는 상수 객체를 사용하는 것이 좋습니다.
<<<<<<< HEAD
=======
=======
>>>>>>> fb20b8f6479e02075d393e253cb1f721dab49775
## 🙋‍♀️ 질문

---
### 3.2.2 선언적인 스타일 대 명령형 스타일 - p.101
결국 우리가 분리 안하고자 하는 부분은 작은 메소드 하나일텐데,
그런 경우는 명령형(정적 메소드)이 더 빠른거라고 말하는 것이 아닌지?

### 3.2.4 싱글톤 패턴
유틸리티 클래스보다는 낫지만 쓰레기다 라고 했는데
싱글톤을 이미 주요 라이브러리에서 사용하고 있는데 진짜 쓰레기인지?
<<<<<<< HEAD
>>>>>>> 7d7d3e3515f425f05a4b632e80acc9e20d12fb43
=======
>>>>>>> fb20b8f6479e02075d393e253cb1f721dab49775
