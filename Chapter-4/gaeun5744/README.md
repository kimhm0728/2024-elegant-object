# 📌 절대 NULL을 반환하지 마세요

만약 함수에서 `null`을 반환한다면, 함수를 호출할 때 마다 항상 `NullPointerException`을 던져질 지도 모른다는 불안감에 떨어야 한다.

객체라는 아이디어에 우리가 신뢰하는 엔티티라는 개념이 담겨져 있다. 객체는 데이터를 담는 봉투가 아니다. 객체는 자신만의 생명주기, 자신만의 행동, 자신만의 상태를 가지는 살아있는 유기체이다.

우리는 객체를 신뢰하기 때문에 객체와 완벽하게 동일한 의미를 가지는 변수 역시 신뢰합니다. 여기서 신뢰한다는 말에는 객체가 자신의 행동을 전적으로 책임지고 우리가 어떤 식으로든 간섭하지 않는다는 의미가 담겨 있다.

객체가 이름을 출력하는 대신 예외를 던지고 싶다면, 우리는 그것을 받아들일 것이다. 객체에게 어떤 말도 하지 않은 채 우리 마음대로 예외를 던져서는 안된다!

반환값을 검사한다는 것은, 신뢰가 부족하다는 명백한 신호이다. 그리고 신뢰 부족은 결과적으로 유지보수성의 심각한 손실로 이어진다. 코드를 읽을 때, 신뢰할 수 있는 메서드 호출이 어떤 것이고 `null`을 반환하는 메서드 호출이 어떤 것인지 이해하기 위해 시간을 더 써야한다.

### ✅ 빠르게 실패하기 vs 안전하게 실패하기

안전하게 실패하기는 버그, 입출력 문제, 메모리 오버플로우 등이 발생한 상황에서도 소프트웨어가 계속 실행될 수 있도록 최대한 많은 일을 하도록 권장합니다.

빠르게 실패하기는 이와는 반대되는 접근 방법을 따른다. 어떤 문제건간에, 일단 문제가 발생하면 곧바로 실행을 중단하고 최대한 빠르게 예외를 던진다. 결과에 대해서는 걱정하지 않는다.

실패를 감추는 대신 강조합니다.

실패를 눈에 잘 띄게 만들고 추적하기 쉽게 만든다.

에러를 발견한 즉시 보고하는 경우에만 안전성과 견고함을 얻을 수 있다고 생각한다. 더 빠르게 문제를 찾을수록 더 빠르게 실패하고, 결과적으로 전체적으로 품질이 향상될 것이다. 반대로 더 오래 숨길수록 문제는 더 커진다.

## ✅ NULL의 대안

1. 메서드를 두 개로 나눈다.

첫 번째 메서드는 객체의 존재를 확인하고, 두 번째 메서드는 객체를 반환한다. 두 번째 메서드에서 아무것도 찾지 못할 경우 예외를 던진다.

```java
public boolean exists(String name) {
	if (/* 데이터베이스에서 발견하지 못했다면 */) {
		return false;
	}

	return true;
}
```

이 접근 방법의 문제점은 데이터베이스에 요청을 두 번 전송하기 때문에 비효율적이다. 먼저 데이터베이스 안에 레코드가 존재하는지 확인하고, 그 후 데이터베이스로부터 시제 객체를 읽어와야 한다.

1. 객체의 컬렉션을 반환

이 문제를 해결할 수 있는 두 번째 방법은 Null이나 예외를 던지는 대신 객체의 컬렉션을 반환하는 것이다.

```java
public Collection<User> users(String name) {
	if(/* 데이터베이스에서 발견하지 못했다면 */) {
		return new ArrayList<>(0);
	}

	return Collections.singleton(/* 데이터베이스로부터 */)
}
```

여기에서는 아무 것도 발견하지 못한 경우 빈 컬렉션을 반환한다.

이 경우 클라이언트는 객체를 추출하기 위해 어떤 식으로든 컬렉션을 통해야만 한다. 그리고 메서드의 이름이 바뀌었다는 사실에 주목하라. 이제 user()가 아니라 users()이다.

1. Null object 디자인 패턴

아무 것도 찾을 수 없을 때 외관상으로는 보통 객체처럼 보이지만 실제로는 다르게 행동하는 객체를 반환한다.

이 접근방법은 객체지향적인 사고방식과 잘 어울리지만, 제한된 상황에서만 사용 가능하다는 단점이 있다. 반환된 객체의 타입을 동일하게 유지해야 한다는 사실에 주의하라.

요약하자면, 절대 NULL을 반환하지 마라

# 📌 체크 예외만 던지세요

Chekced Exception을 던지는 메서드는 분란을 일으킬 수 있기 때문에 실제로 ‘안전’하지 않다.

```java
public int length(File file) {
	try {
		return content(file).length();
	} catch (IOException ex) {
		// 이 예외에 대해 어떤 처리를 해야하며
		// 바로 여기에서 예외를 해결하거나
		// 더 상위 레벨로 전달해야 한다.
	}
}
```

해당 메서드는 입출력 시스템에서 발생한 문제로 인해 실패할 수 있다. 메서드가 `IOException` 을 던지기 때문에 우리는 메서드의 실패 원인이 파일 시스템과 관련이 있다고 가정할 수 있고, `IOException` 을 던지겠다고이야기 함으로써 메서드는 책임이라는 짐을 우리의 어깨 위로 옮겨버린 것이다. 파에 어떤 어떤 문제가 발생했을 때, 무엇을 해야 할지를 객체가 아닌 우리가 결정하도록 만들고 있다.

우리는 해당 메서드가 예외를 발생시킬 것이라는 사실을 무시할 수 없다. 예외를 잡거나, 아니면 예외를 상위로 전파하기 위해 `throws IOException` 구문을 메서드 시그니처에 선언해야 한다.

이와 반대로 Unchecked 예외는 무시하거나 아예 잡지 않을 수 있다. 일단 언체크 예외를 던지면, 누군가 예외를 잡기 전까지 자동으로 상위로 전파된다. 하지만 언어는 예외를 처리하도록 강요하지 않는다.

## ✅ 꼭 그래야만 하는게 아니라면 예외를 잡지 마세요

가능하면 예외를 더 높은 레벨로 전파해야 한다. 모든 catch 문은 존재해야만 하는 타당한 이유가 있어야 한다. 다시 말해서, 꼭 예외를 잡아야 하는 경우가 아니거나 다른 선택의 여지가 없는 경우가 아니라면 예외를 잡지 말아야 한다.

이상적인 설계에서는 어플리케이션의 각 진입점 별로 오직 하나의 catch 문만 존재해야 한다. 예를 들어 핸드폰 화면을 통해 사용자와 의사소통하는 모바일 앱의 경우, 전체 어플리케이션에 오직 하나의 진입점과 하나의 catch 문만 존재해야 한다.

문제가 발생한 장소에서 어떻게든 문제를 해결해서 소프트웨어를 견고하게 만드는 철학은 코드 전체를 유지보수하기 어렵고 매우 불안정하게 만든다.

예외를 던지지 않고 구조하는 매 순간마다, 안전하게 실패하기 라는 사고방식으로 여러분 자신을 떠맡고 있는 것이다.

## ✅ 항상 예외를 체이닝하세요

```java
try {
	return content(file).length();
} catch (IOException ex) {
	throw new Exception("길이를 계산할 수 없다", ex);
}
```

위는 원래의 예외를 새로운 예외로 대체함으로써 문제가 발생했다는 사실을 무시하지 않는다.

```java
try {
	return content(file).length();
} catch (IOException ex) {
	// 여기에서는 문제 'ex'를 무시하고,
	// 새로운 메시지를 가지는 새로운 타입의 새로운 문제를
	// 생성한다.
	throw new Exception("길이를 계산할 수 없다");
}
```

이러한 방식은 문제를 발생시킨 근본 원인과 관련된 매우 가치있는 정보를 잃기 때문에 매우 나쁜 프랙티스이다.

이 새로운 예외는 상위로 전파될 것이고, 최종적으로 어플리케이션의 상위 수준에 위치한 catch 문에서 잡힐 것이다. 매우 가치 있는 저수준 정보가 사라져버린 것이다.

예외 체이닝은 의미론적으로 문제와 관련된 문맥을 풍부하게 만들기 때문에 중요하다

예외를 잡고 체이닝 하는 것이 예외를 처리할 수 있는 최선의 방법이다.

## ✅ 단 한번만 복구하세요

모든 메서드는 예외를 던져야 하고 결코 잡아서는 안된다. 따라서 모든 예외는 어플리케이션의 가장 높은 위치, 실제로는 다수의 지점으로 전파될 것이다.

여기서 높은 위치란 사용자가 어플리케이션과 커뮤니케이션하는 진입점을 의미한다.

모든 진입점에서 동일한 작업이 수행되어야 한다. 복잡한 시스템에서조차 진입점은 그리 많지 않다. 여기에서 말하고 싶은 것은 어떤 소프트웨어에서든 복구에 적합한 몇 개의 장소가 존재한다는 것이다.

# 📌 질문

171p. 사실 단 한번만 복구한다면, 모든 예외들을 내부에 포함할 수 있는 단 하나의 예외 객체만 가지게 됩니다. 적절하게 체이닝되었다면, 예외의 타입을 알아야 할 이유가 있을까요?

→ 원래 예외를 무시하지 않고, 새로운 예외로 감싸서 계속 던지기 때문에 근본적인 원인을 알수 있다. 그러므로 예외 타입을 알아야 할 이유가 없다는 말일까요?

178~179p.

너무 한정적인 경우에서만 사용이 가능할 것 같습니다.
